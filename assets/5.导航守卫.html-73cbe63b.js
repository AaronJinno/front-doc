import{_ as n,o as a,c as s,e}from"./app-2b89a278.js";const t={},p=e(`<h4 id="_1-介绍" tabindex="-1"><a class="header-anchor" href="#_1-介绍" aria-hidden="true">#</a> 1. 介绍</h4><p>vue-router提供的导航守卫主要用来监听路由的进入和离开的（导航即路由发生改变）。<br> vue-router提供了beforeEach和afterEach的钩子函数, 它们会在路由即将改变前和改变后触发。</p><p>本质：导航守卫的本质就是个路由中间件，过滤器。<br> PS ：param和query的改变不会触发导航守卫。</p><h4 id="_2-全局前置守卫" tabindex="-1"><a class="header-anchor" href="#_2-全局前置守卫" aria-hidden="true">#</a> 2. 全局前置守卫</h4><p>router.beforeEach：全局前置守卫，当任意导航触发时（生效前）调用。</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">const</span> router <span class="token operator">=</span> <span class="token function">createRouter</span><span class="token punctuation">(</span><span class="token punctuation">{</span> <span class="token operator">...</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>
router<span class="token punctuation">.</span><span class="token function">beforeEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">to<span class="token punctuation">,</span> <span class="token keyword">from</span></span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token comment">//return false</span>
  <span class="token comment">//return true</span>
  <span class="token comment">//return &#39;/login&#39;</span>
  <span class="token keyword">return</span> <span class="token punctuation">{</span> <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">&#39;Login&#39;</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h5 id="_2-1-参数" tabindex="-1"><a class="header-anchor" href="#_2-1-参数" aria-hidden="true">#</a> 2.1 参数</h5><ul><li>to: Route对象，即将要进入的目标路由对象(<code>this.$route</code>)</li><li>from: Route对象，当前导航正要离开的路由</li></ul><h5 id="_2-2-返回值" tabindex="-1"><a class="header-anchor" href="#_2-2-返回值" aria-hidden="true">#</a> 2.2 返回值</h5><ul><li>false： 取消当前的导航，如果URL改变了，会重置到from路由对应的地址</li><li>一个路由地址：通过一个路由地址跳转到一个不同的地址，相当于调用router.push()。 <ul><li>可以设置诸如 replace: true 或 name: &#39;home&#39; 之类的配置。</li></ul></li><li>如果什么都没有、undefined 、 true，则导航是有效的，并调用下一个导航守卫</li></ul><h5 id="_2-3-next方法" tabindex="-1"><a class="header-anchor" href="#_2-3-next方法" aria-hidden="true">#</a> 2.3 next方法</h5><p>可以向任何导航守卫传递第三个参数next，这是一个可选参数，如果传递了就要确保 next 函数在任何给定的导航守卫中都被严格调用一次，它可以出现多于一次。</p><ul><li>next()：进行下一步（其他钩子，或者完成跳转）</li><li>next(false)：终止导航，重置回from对应的路由</li><li>next(&#39;/&#39;)或者 next({ path: &#39;/&#39; })：跳转到一个指定的路由，而不是to对应的路由</li><li>next(error)：报错，不常用。</li></ul><h5 id="_2-4-示例-登录验证" tabindex="-1"><a class="header-anchor" href="#_2-4-示例-登录验证" aria-hidden="true">#</a> 2.4 示例：登录验证</h5><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code>router<span class="token punctuation">.</span><span class="token function">beforeEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">to<span class="token punctuation">,</span>from<span class="token punctuation">,</span>next</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>to<span class="token punctuation">.</span>name <span class="token operator">!==</span><span class="token string">&#39;Login&#39;</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>isAuthenticated<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token literal-property property">name</span><span class="token operator">:</span><span class="token string">&#39;Login&#39;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//未登录，且前往的不是登录页，则跳转到登录页</span>
    <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>
        <span class="token keyword">else</span> <span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//已登录，或要访问的就是登录页，就放行</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_3-全局解析守卫" tabindex="-1"><a class="header-anchor" href="#_3-全局解析守卫" aria-hidden="true">#</a> 3. 全局解析守卫</h4><p>可以用 router.beforeResolve 注册一个全局守卫。这和 router.beforeEach 类似，因为它在 每次导航时都会触发，但是确保在导航被确认之前，同时在所有组件内守卫和异步路由组件被解析之后，解析守卫就被正确调用。</p><p>用的不多，暂略。</p><h4 id="_4-全局后置钩子" tabindex="-1"><a class="header-anchor" href="#_4-全局后置钩子" aria-hidden="true">#</a> 4. 全局后置钩子</h4><p>这个钩子是在导航改变之后调用的，和守卫不同的是，这些钩子不会接受 next 函数也不会改变导航本身。</p><p>用途：分析、更改页面标题、声明页面等辅助功能，判断用户是否第一次登录，将访问的URL写入日志。</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code>router<span class="token punctuation">.</span><span class="token function">afterEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">to<span class="token punctuation">,</span> <span class="token keyword">from</span></span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token function">sendToAnalytics</span><span class="token punctuation">(</span>to<span class="token punctuation">.</span>fullPath<span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_5-路由独享守卫" tabindex="-1"><a class="header-anchor" href="#_5-路由独享守卫" aria-hidden="true">#</a> 5. 路由独享守卫</h4><p>上面的全局守卫都是所有路由都生效的，也可以在路由内部设置守卫，专门针对该路由生效。</p><p>用法与全局前置守卫是一样的</p><p>beforeEnter：只在进入路由时触发，不会在 params、query 或 hash 改变时触发</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token punctuation">{</span>
    <span class="token literal-property property">path</span><span class="token operator">:</span><span class="token string">&#39;/profile/:id&#39;</span><span class="token punctuation">,</span>
    <span class="token literal-property property">component</span><span class="token operator">:</span>Profile<span class="token punctuation">,</span>
    <span class="token function-variable function">beforeEnter</span><span class="token operator">:</span><span class="token punctuation">(</span><span class="token parameter">to<span class="token punctuation">,</span><span class="token keyword">from</span></span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token boolean">false</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_6-组件内的守卫" tabindex="-1"><a class="header-anchor" href="#_6-组件内的守卫" aria-hidden="true">#</a> 6. 组件内的守卫</h4><p>可以在路由组件内直接定义以下路由导航守卫：（参数跟和用法其他守卫一样）。</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">const</span> Foo <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token literal-property property">template</span><span class="token operator">:</span> <span class="token template-string"><span class="token template-punctuation string">\`</span><span class="token string">...</span><span class="token template-punctuation string">\`</span></span><span class="token punctuation">,</span>
  <span class="token function">beforeRouteEnter</span> <span class="token punctuation">(</span><span class="token parameter">to<span class="token punctuation">,</span> from<span class="token punctuation">,</span> next</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 在渲染该组件的对应路由被 confirm 前调用</span>
    <span class="token comment">// 不！能！获取组件实例 \`this\`</span>
    <span class="token comment">// 因为当守卫执行前，组件实例还没被创建</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token function">beforeRouteUpdate</span> <span class="token punctuation">(</span><span class="token parameter">to<span class="token punctuation">,</span> from<span class="token punctuation">,</span> next</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 在当前路由改变，但是该组件被复用时调用举例来说，对于一个带有动态参数的路径 </span>
    <span class="token comment">// /foo/:id，在 /foo/1 和 /foo/2 之间跳转的时候，由于会渲染同样的 Foo 组件</span>
    <span class="token comment">//因此组件实例会被复用。而这个钩子就会在这个情况下被调用。</span>
    <span class="token comment">//可以访问组件实例 \`this\`</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token function">beforeRouteLeave</span> <span class="token punctuation">(</span><span class="token parameter">to<span class="token punctuation">,</span> from<span class="token punctuation">,</span> next</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 导航离开该组件的对应路由时调用</span>
    <span class="token comment">// 可以访问组件实例 \`this\`</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>组合式API：可以通过 onBeforeRouteUpdate 和 onBeforeRouteLeave 分别添加 update 和 leave 守卫</p><h4 id="_7-整的导航解析流程" tabindex="-1"><a class="header-anchor" href="#_7-整的导航解析流程" aria-hidden="true">#</a> 7. 整的导航解析流程</h4><ul><li>导航被触发。</li><li>在失活的组件里调用 beforeRouteLeave 守卫。</li><li>调用全局的 beforeEach 守卫。</li><li>在重用的组件里调用 beforeRouteUpdate 守卫(2.2+)。</li><li>在路由配置里调用 beforeEnter。</li><li>解析异步路由组件。</li><li>在被激活的组件里调用 beforeRouteEnter。</li><li>调用全局的 beforeResolve 守卫(2.5+)。</li><li>导航被确认。</li><li>调用全局的 afterEach 钩子。</li><li>触发 DOM 更新。</li><li>调用 beforeRouteEnter 守卫中传给 next 的回调函数，创建好的组件实例会作为回调函数的参数传入。</li></ul>`,33),o=[p];function i(c,l){return a(),s("div",null,o)}const u=n(t,[["render",i],["__file","5.导航守卫.html.vue"]]);export{u as default};
