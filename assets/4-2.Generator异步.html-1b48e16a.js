import{_ as n,o as a,c as s,e}from"./app-ba294a04.js";const t={},p=e(`<p>异步编程对 JS 语言太重要。JS 语言的执行环境是“单线程”的，如果没有异步编程，根本没法用，非卡死不可。本章主要介绍 Generator 函数如何完成异步操作。</p><h2 id="i-基本概念" tabindex="-1"><a class="header-anchor" href="#i-基本概念" aria-hidden="true">#</a> Ⅰ. 基本概念</h2><h4 id="_1-传统异步方法" tabindex="-1"><a class="header-anchor" href="#_1-传统异步方法" aria-hidden="true">#</a> 1. 传统异步方法</h4><ul><li>回调函数</li><li>事件监听</li><li>发布/订阅</li><li>Promise对象</li></ul><h4 id="_2-异步" tabindex="-1"><a class="header-anchor" href="#_2-异步" aria-hidden="true">#</a> 2. 异步</h4><p>所谓&quot;异步&quot;，简单说就是一个任务不是连续完成的，可以理解成该任务被人为分成两段，先执行第一段，然后转而执行其他任务，等做好了准备，再回过头执行第二段。</p><p>例如：读取文件进行处理，第一步发起读取文件的请求，然后JS继续执行其他任务，等系统返回文件后再执行第二步（处理文件），这种不连续的执行就叫异步。</p><p>连续的执行就叫同步。连续执行是不能插入其他任务的，如果某一步消耗时间比较长，JS程序就只能干等着，比较不友好。</p><h4 id="_3-回调函数" tabindex="-1"><a class="header-anchor" href="#_3-回调函数" aria-hidden="true">#</a> 3. 回调函数</h4><p>JS对异步编程的基本实现就是回调函数。回调函数，就是把任务的第二段单独写在一个函数里面，等到重新执行这个任务的时候，就直接调用这个函数。</p><p>Node 约定，回调函数的第一个参数，必须是错误对象err（如果没有错误，该参数就是null）。原因是执行分成两段，第一段执行完以后，任务所在的上下文环境就已经结束了。在这以后抛出的错误，原来的上下文环境已经无法捕捉，只能当作参数，传入第二段。</p><h4 id="_4-promise" tabindex="-1"><a class="header-anchor" href="#_4-promise" aria-hidden="true">#</a> 4. Promise</h4><p>回调函数本身并没有问题，它的问题出现在多个回调函数嵌套，形成回调地狱。</p><p>Promise可以解决回调地狱，Promise最大的问题是过于冗余，可以采用Generator函数来解决。</p><h2 id="ii-generator函数" tabindex="-1"><a class="header-anchor" href="#ii-generator函数" aria-hidden="true">#</a> Ⅱ. Generator函数</h2><h4 id="_1-协程" tabindex="-1"><a class="header-anchor" href="#_1-协程" aria-hidden="true">#</a> 1. 协程</h4><p>意思是多个线程互相协作（并不是多线程），完成异步任务，JS只有一个线程，如果需要并发，协程是唯一的选择。协程可以简化代码，避免回调地狱，相比线程，协程占用资源更少。</p><h5 id="_1-1-协程的大致运行流程" tabindex="-1"><a class="header-anchor" href="#_1-1-协程的大致运行流程" aria-hidden="true">#</a> 1.1 协程的大致运行流程</h5><ul><li>协程 a 开始执行</li><li>协程 a 执行到一半，进入暂停，执行权转移到协程b</li><li>一段时间后，协程 b 交还执行权。</li><li>协程 a 恢复执行。<br> 上面流程的协程 a，就是异步任务，因为它分成两段（或多段）执行。</li></ul><h5 id="_1-2-协程的特点" tabindex="-1"><a class="header-anchor" href="#_1-2-协程的特点" aria-hidden="true">#</a> 1.2 协程的特点</h5><ul><li>可以暂停执行（暂停的表达式称为暂停点）；</li><li>可以从挂起点恢复（保留其原始参数和局部变量）<br> 在JS中，拥有以上特点的就是Generator函数。</li></ul><h5 id="_1-3-进程、线程和协程的比较" tabindex="-1"><a class="header-anchor" href="#_1-3-进程、线程和协程的比较" aria-hidden="true">#</a> 1.3 进程、线程和协程的比较</h5><ul><li>进程：变量隔离，自动切换运行上下文【程序的一次执行, 它占有一片独有的内存空间，可以通过windows任务管理器查看进程】</li><li>线程：不变量隔离，自动切换运行上下文切换【是进程内的一个独立执行单元，是程序执行的一个完整流程】</li><li>协程：不变量隔离，不自动切换运行上下文切换</li></ul><h5 id="_1-4-generator协程示例" tabindex="-1"><a class="header-anchor" href="#_1-4-generator协程示例" aria-hidden="true">#</a> 1.4 Generator协程示例</h5><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">function</span><span class="token operator">*</span> <span class="token function">gen</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token operator">...</span>
    <span class="token keyword">yield</span> <span class="token function">readFile</span><span class="token punctuation">(</span>fileA<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//读取文件时，进入协程，将执行权交给其他协程</span>
    <span class="token operator">...</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_2-协程的generator函数实现" tabindex="-1"><a class="header-anchor" href="#_2-协程的generator函数实现" aria-hidden="true">#</a> 2. 协程的Generator函数实现</h4><p>Generator 函数是协程在 ES6 的实现，最大特点就是可以交出函数的执行权（即暂停执行）。</p><p>整个 Generator 函数就是一个封装的异步任务，或者说是异步任务的容器。异步操作需要暂停的地方，都用yield语句注明。Generator 函数的执行方法如下。</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">function</span><span class="token operator">*</span> <span class="token function">gen</span><span class="token punctuation">(</span><span class="token parameter">x</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">let</span> y <span class="token operator">=</span> <span class="token keyword">yield</span> x<span class="token operator">+</span><span class="token number">2</span><span class="token punctuation">;</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span> <span class="token comment">//打印的是undefined</span>
    <span class="token keyword">return</span> y<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">let</span> g <span class="token operator">=</span> <span class="token function">gen</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
g<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">//{value:3,done:false} ,执行到x+2;并未进行赋值到y</span>
g<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">//{value:undefined,done:true} ,y并未被赋值成功</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>执行generator函数不会返回执行结果，而是返回一个指针，调用指针的next方法，会移动指针到yield，并执行移动过程中的语句。</p><p>next方法的作用是分阶段执行Generator函数。每次调用next方法，会返回一个对象，表示当前阶段的信息（value属性和done属性）。value属性是yield语句后面表达式的值，表示当前阶段的值；done属性是一个布尔值，表示 Generator 函数是否执行完毕。</p><h4 id="_3-generator函数的数据交换和错误处理" tabindex="-1"><a class="header-anchor" href="#_3-generator函数的数据交换和错误处理" aria-hidden="true">#</a> 3. Generator函数的数据交换和错误处理</h4><p>Generator 函数可以暂停执行和恢复执行，这是它能封装异步任务的根本原因。除此之外，它还有两个特性，使它可以作为异步编程的完整解决方案：函数体内外的数据交换和错误处理机制。</p><h5 id="_3-1-数据交互" tabindex="-1"><a class="header-anchor" href="#_3-1-数据交互" aria-hidden="true">#</a> 3.1 数据交互</h5><p>next返回值的 value 属性，是 Generator 函数向外输出数据（yield后的表达式）；next方法还可以接受参数，向 Generator 函数体内输入数据</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">function</span><span class="token operator">*</span> <span class="token function">gen</span><span class="token punctuation">(</span><span class="token parameter">x</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">let</span> y <span class="token operator">=</span> <span class="token keyword">yield</span> x<span class="token operator">+</span><span class="token number">2</span><span class="token punctuation">;</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span> 
    <span class="token keyword">return</span> y<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">let</span> g <span class="token operator">=</span> <span class="token function">gen</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
g<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">//{value:3,done:false} ,value是gen传递的值+2。</span>
g<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//{value:10,done:true} ,将参数传入gen，y被赋值。</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>第一个next方法的value属性，返回表达式x + 2的值3。第二个next方法带有参数10，这个参数可以传入 Generator 函数，<strong>作为上个阶段异步任务的返回结果</strong>，被函数体内的变量y接收。因此，这一步的value属性，返回的就是10（变量y的值）。</p><h5 id="_3-2-错误处理" tabindex="-1"><a class="header-anchor" href="#_3-2-错误处理" aria-hidden="true">#</a> 3.2 错误处理</h5><p>Generator 函数内部还可以部署错误处理代码，捕获函数体外抛出的错误。这意味着，出错的代码与处理错误的代码，实现了时间和空间上的分离，这对于异步编程无疑是很重要的。</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">function</span><span class="token operator">*</span> <span class="token function">gen</span><span class="token punctuation">(</span><span class="token parameter">x</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">try</span><span class="token punctuation">{</span>
        <span class="token keyword">var</span> y <span class="token operator">=</span> <span class="token keyword">yield</span> x <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token keyword">catch</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> y<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">let</span> g <span class="token operator">=</span> <span class="token function">gen</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
g<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
g<span class="token punctuation">.</span><span class="token function">throw</span><span class="token punctuation">(</span><span class="token string">&#39;wrong&#39;</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_4-异步任务的封装" tabindex="-1"><a class="header-anchor" href="#_4-异步任务的封装" aria-hidden="true">#</a> 4. 异步任务的封装</h4><p>对Generator函数，进行真实的异步任务封装</p><p>示例：异步读取一个接口</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">let</span> fetch <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">&#39;node-fetch&#39;</span><span class="token punctuation">)</span> <span class="token comment">//一个读取接口的模块，返回Promise</span>
<span class="token keyword">function</span><span class="token operator">*</span> <span class="token function">gen</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">let</span> url <span class="token operator">=</span> <span class="token string">&quot;https://api.sgugo.com/v2/user/1102&quot;</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> result <span class="token operator">=</span> <span class="token keyword">yield</span> <span class="token function">fetch</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span><span class="token punctuation">;</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>result<span class="token punctuation">.</span>uname<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">let</span> g <span class="token operator">=</span> <span class="token function">gen</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> result <span class="token operator">=</span> g<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//执行fetch，获取接口的返回结果，value是一个Promise</span>
result<span class="token punctuation">.</span>value<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">v</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">return</span> v<span class="token punctuation">.</span><span class="token function">json</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//获取json结果</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">v</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    g<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//传值，需要用then调用下一个next</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Generator 函数封装了一个异步操作，该操作先读取一个远程接口，然后从 JSON 格式的数据解析信息。首先执行 Generator 函数，获取遍历器对象，然后使用next方法，执行异步任务的第一阶段。由于Fetch模块返回的是一个 Promise 对象，因此要用then方法调用下一个next方法。</p><p>虽然 Generator 函数将异步操作表示得很简洁，但是流程管理却不方便（即何时执行第一阶段、何时执行第二阶段</p><h2 id="iii-thunk函数" tabindex="-1"><a class="header-anchor" href="#iii-thunk函数" aria-hidden="true">#</a> Ⅲ. Thunk函数</h2><p>Thunk 函数是自动执行 Generator 函数的一种方法。</p><div class="hint-container tip"><p class="hint-container-title">提示</p><p>暂略</p></div><h2 id="iv-co模块" tabindex="-1"><a class="header-anchor" href="#iv-co模块" aria-hidden="true">#</a> Ⅳ. co模块</h2><p>co 模块是著名程序员 TJ Holowaychuk 于 2013 年 6 月发布的一个小工具，用于 Generator 函数的自动执行</p><div class="hint-container tip"><p class="hint-container-title">提示</p><p>暂略</p></div>`,52),o=[p];function c(i,l){return a(),s("div",null,o)}const r=n(t,[["render",c],["__file","4-2.Generator异步.html.vue"]]);export{r as default};
