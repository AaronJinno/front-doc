import{_ as a,P as s,Q as n,a5 as e}from"./framework-3728cbf1.js";const t={},p=e(`<h4 id="_1-regexp构造函数" tabindex="-1"><a class="header-anchor" href="#_1-regexp构造函数" aria-hidden="true">#</a> 1. RegExp构造函数</h4><h5 id="_1-1-es5" tabindex="-1"><a class="header-anchor" href="#_1-1-es5" aria-hidden="true">#</a> 1.1 ES5</h5><p>在 ES5 中，RegExp构造函数的参数有两种情况。</p><ul><li>参数是字符串（注意要转义），此时参数2表示模式修饰符(flag).</li><li>参数是正则表达式，此时仅有一个参数，加模式修饰符作为参数2会报错</li></ul><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">var</span> regex <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">RegExp</span><span class="token punctuation">(</span><span class="token string">&#39;xyz&#39;</span><span class="token punctuation">,</span> <span class="token string">&#39;i&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 等价于var regex = /xyz/i;</span>
<span class="token keyword">var</span> regex <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">RegExp</span><span class="token punctuation">(</span><span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">xyz</span><span class="token regex-delimiter">/</span><span class="token regex-flags">i</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 等价于var regex = /xyz/i;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h5 id="_1-2-es6" tabindex="-1"><a class="header-anchor" href="#_1-2-es6" aria-hidden="true">#</a> 1.2 ES6</h5><p>ES6中，运行参数是正则表达式的情况下，依然启用参数2，添加模式修正符，此时，参数2的模式修饰符会覆盖参数1的模式修正符。</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">var</span> regex <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">RegExp</span><span class="token punctuation">(</span><span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">xyz</span><span class="token regex-delimiter">/</span><span class="token regex-flags">ig</span></span><span class="token punctuation">,</span><span class="token string">&#39;i&#39;</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h4 id="_2-字符串的正则方法" tabindex="-1"><a class="header-anchor" href="#_2-字符串的正则方法" aria-hidden="true">#</a> 2. 字符串的正则方法</h4><p>字符串对象共有 4 个方法，可以使用正则表达式：match()、replace()、search()和split()。 ES6 将这 4 个方法，在语言内部全部调用RegExp的实例方法，从而做到所有与正则相关的方法，全都定义在RegExp对象上。</p><ul><li>String.prototype.match 调用 RegExp.prototype[ Symbol.match]</li><li>String.prototype.replace 调用 RegExp.prototype[ Symbol.replace]</li><li>String.prototype.search 调用 RegExp.prototype[ Symbol.search]</li><li>String.prototype.split 调用 RegExp.prototype[ Symbol.split]</li></ul><h4 id="_3-u修饰符" tabindex="-1"><a class="header-anchor" href="#_3-u修饰符" aria-hidden="true">#</a> 3. u修饰符</h4><p>ES6 对正则表达式添加了u修饰符，含义为“Unicode 模式”，用来正确处理大于 <code>\\uFFFF</code> 的 Unicode 字符。也就是说，会正确处理四个字节的 UTF-16 编码。</p><h4 id="_4-regexp-prototype-unicode属性" tabindex="-1"><a class="header-anchor" href="#_4-regexp-prototype-unicode属性" aria-hidden="true">#</a> 4. RegExp.prototype.unicode属性</h4><p>正则实例对象新增unicode属性，表示是否设置了u修饰符。</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">const</span> r1 <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">hello</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">;</span>
<span class="token keyword">const</span> r2 <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">hello</span><span class="token regex-delimiter">/</span><span class="token regex-flags">u</span></span><span class="token punctuation">;</span>
r1<span class="token punctuation">.</span>unicode <span class="token comment">// false</span>
r2<span class="token punctuation">.</span>unicode <span class="token comment">// true</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_5-y修饰符-sticky修饰符" tabindex="-1"><a class="header-anchor" href="#_5-y修饰符-sticky修饰符" aria-hidden="true">#</a> 5. y修饰符：sticky修饰符</h4><p>y修饰符的作用与g修饰符类似，不同之处在于，g修饰符只要剩余位置中存在匹配就可，而y修饰符确保匹配必须从剩余的第一个位置开始且自动添加了^，这也就是“sticky”的涵义。</p><h5 id="_5-1-y修饰符的原理" tabindex="-1"><a class="header-anchor" href="#_5-1-y修饰符的原理" aria-hidden="true">#</a> 5.1 y修饰符的原理</h5><ul><li>y修饰符相当于g修饰符在每次匹配的时候加了:1个限制。</li><li>必须从剩余字符的第一个字符开始匹配，第一个字符不符合，就失败。而g并没有这个限制，会一直向后走，直接匹配到为止。相当于在每次匹配时，都在头部隐含了^。</li><li>正因为隐含了^，所以每次匹配必须从剩余字符的第一个字符开始比对。</li></ul><h5 id="_5-2-y与g的比较" tabindex="-1"><a class="header-anchor" href="#_5-2-y与g的比较" aria-hidden="true">#</a> 5.2 y与g的比较</h5><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">var</span> s <span class="token operator">=</span> <span class="token string">&#39;aaa_aa_a&#39;</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> r1 <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">a+</span><span class="token regex-delimiter">/</span><span class="token regex-flags">g</span></span><span class="token punctuation">;</span>
<span class="token keyword">var</span> r2 <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">a+</span><span class="token regex-delimiter">/</span><span class="token regex-flags">y</span></span><span class="token punctuation">;</span>

r1<span class="token punctuation">.</span><span class="token function">exec</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token comment">// [&quot;aaa&quot;]</span>
r2<span class="token punctuation">.</span><span class="token function">exec</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token comment">// [&quot;aaa&quot;] ===/^a+/.exec(&#39;aaa_aa_a&#39;);</span>

r1<span class="token punctuation">.</span><span class="token function">exec</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token comment">// [&quot;aa&quot;]</span>
r2<span class="token punctuation">.</span><span class="token function">exec</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token comment">// null ===/^a+/.exec(&#39;_aa_a&#39;);</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h5 id="_5-3-y修饰符的意义和应用" tabindex="-1"><a class="header-anchor" href="#_5-3-y修饰符的意义和应用" aria-hidden="true">#</a> 5.3 y修饰符的意义和应用</h5><ul><li>y修饰符的设计本意，就是让头部匹配的标志^在全局匹配中都有效。</li><li>y修饰符的一个应用，是从字符串提取 token，y修饰符确保了匹配之间不会有漏掉的字符。</li><li>g修饰符会忽略非法字符，而y修饰符不会，这样就很容易发现错误。</li></ul><h5 id="_5-4-match方法说明" tabindex="-1"><a class="header-anchor" href="#_5-4-match方法说明" aria-hidden="true">#</a> 5.4 match方法说明</h5><p>y修饰符对match方法，只能返回第一个匹配，必须与g修饰符联用，才能返回所有匹配。</p><h4 id="_6-s修饰符-dotall模式" tabindex="-1"><a class="header-anchor" href="#_6-s修饰符-dotall模式" aria-hidden="true">#</a> 6. s修饰符：dotAll模式</h4><p><code>.</code> 是一个特殊字符，代表任意的单个字符，但是它不能匹配行终止符（换行、回车、行分隔、段分隔）。dotAll模式就可以匹配行终止符。</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">let</span> str <span class="token operator">=</span> <span class="token template-string"><span class="token template-punctuation string">\`</span><span class="token string">
  &lt;ul&gt;
    &lt;li&gt;
      &lt;a&gt;one-a&lt;/a&gt;
      &lt;p&gt;one-p&lt;/p&gt;
    &lt;/li&gt;
    &lt;li&gt;
      &lt;a&gt;two-a&lt;/a&gt;
      &lt;p&gt;two-p&lt;/p&gt;
    &lt;/li&gt;  
  &lt;/ul&gt;
</span><span class="token template-punctuation string">\`</span></span><span class="token punctuation">;</span> <span class="token comment">//如上，需求是匹配&lt;li&gt;和后面的两行</span>
<span class="token keyword">let</span> reg1 <span class="token operator">=</span>  <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">&lt;li&gt;&lt;a&gt;(.*?)&lt;\\/a&gt;&lt;p&gt;(.*?)&lt;\\/p&gt;</span><span class="token regex-delimiter">/</span><span class="token regex-flags">g</span></span><span class="token punctuation">;</span> <span class="token comment">//失败，没匹配换行符</span>
<span class="token keyword">let</span> reg2 <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">&lt;li&gt;.*?&lt;a&gt;(.*?)&lt;\\/a&gt;.*?&lt;p&gt;(.*?)&lt;\\/p&gt;</span><span class="token regex-delimiter">/</span><span class="token regex-flags">g</span></span><span class="token punctuation">;</span> <span class="token comment">//失败，.无法匹配换行符</span>
<span class="token keyword">let</span> reg3 <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">&lt;li&gt;\\s+&lt;a&gt;(.*?)&lt;\\/a&gt;\\s+&lt;p&gt;(.*?)&lt;\\/p&gt;</span><span class="token regex-delimiter">/</span><span class="token regex-flags">g</span></span><span class="token punctuation">;</span><span class="token comment">//成功，\\s可以匹配换行符</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h5 id="_6-1-s修饰符" tabindex="-1"><a class="header-anchor" href="#_6-1-s修饰符" aria-hidden="true">#</a> 6.1 s修饰符</h5><p>加上s修饰符，进入dotAll模式，使得(.)可以匹配任意单个字符。</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">let</span> reg4 <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">&lt;li&gt;.*?&lt;a&gt;(.*?)&lt;\\/a&gt;.*?&lt;p&gt;(.*?)&lt;\\/p&gt;</span><span class="token regex-delimiter">/</span><span class="token regex-flags">gs</span></span><span class="token punctuation">;</span>
<span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">a.b</span><span class="token regex-delimiter">/</span><span class="token regex-flags">s</span></span><span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span><span class="token string">&#39;a\\nb&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//true; dotall模式(.)可以匹配\\n</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h5 id="_6-2-dotall属性" tabindex="-1"><a class="header-anchor" href="#_6-2-dotall属性" aria-hidden="true">#</a> 6.2 dotAll属性</h5><p>正则表达式引入dotAll属性，返回一个布尔值，表示该正则表达式是否处在dotAll模式。</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code>reg<span class="token punctuation">.</span>dotAll <span class="token comment">//true;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h4 id="_7-后行断言-反向断言" tabindex="-1"><a class="header-anchor" href="#_7-后行断言-反向断言" aria-hidden="true">#</a> 7. 后行断言（反向断言）</h4><p>正则有零宽断言，JS在ES5只有先行断言和负向先行断言，没有后行断言，ES6加入了后行断言</p><h5 id="_7-1-先行断言介绍" tabindex="-1"><a class="header-anchor" href="#_7-1-先行断言介绍" aria-hidden="true">#</a> 7.1 先行断言介绍</h5><p>“先行断言”指的是，x只有在y前面才匹配，必须写成<code>/x(?=y)/</code>。比如，只匹配百分号之前的数字，要写成<code>/\\d+(?=%)/</code>。“先行否定断言”指的是，x只有不在y前面才匹配，必须写成<code>/x(?!y)/</code>。比如，只匹配不在百分号之前的数字，要写成<code>/\\d+(?!%)/</code>。</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">(?&lt;=\\$)\\d+</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">.</span><span class="token function">exec</span><span class="token punctuation">(</span><span class="token string">&#39;Benjamin Franklin is on the $100 bill&#39;</span><span class="token punctuation">)</span>  <span class="token comment">// [&quot;100&quot;]</span>
<span class="token operator">/</span><span class="token punctuation">(</span><span class="token operator">?</span><span class="token operator">&lt;</span><span class="token operator">!</span>\\$<span class="token punctuation">)</span>\\d<span class="token operator">+</span><span class="token operator">/</span><span class="token punctuation">.</span><span class="token function">exec</span><span class="token punctuation">(</span><span class="token string">&#39;it’s is worth about €90&#39;</span><span class="token punctuation">)</span>                <span class="token comment">// [&quot;90&quot;]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h5 id="_7-2-后行断言" tabindex="-1"><a class="header-anchor" href="#_7-2-后行断言" aria-hidden="true">#</a> 7.2 后行断言</h5><p>“后行断言”正好与“先行断言”相反，x只有在y后面才匹配，必须写成<code>/(?&lt;=y)x/</code>。比如，只匹配美元符号之后的数字，要写成<code>/(?&lt;=\\$)\\d+/</code>。“后行否定断言”则与“先行否定断言”相反，x只有不在y后面才匹配，必须写成<code>/(?&lt;!y)x/</code>。比如，只匹配不在美元符号后面的数字，要写成<code>/(?&lt;!\\$)\\d+/</code>。</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">(?&lt;=\\$)\\d+</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">.</span><span class="token function">exec</span><span class="token punctuation">(</span><span class="token string">&#39;Benjamin Franklin is on the $100 bill&#39;</span><span class="token punctuation">)</span>  <span class="token comment">// [&quot;100&quot;]</span>
<span class="token operator">/</span><span class="token punctuation">(</span><span class="token operator">?</span><span class="token operator">&lt;</span><span class="token operator">!</span>\\$<span class="token punctuation">)</span>\\d<span class="token operator">+</span><span class="token operator">/</span><span class="token punctuation">.</span><span class="token function">exec</span><span class="token punctuation">(</span><span class="token string">&#39;it’s is worth about €90&#39;</span><span class="token punctuation">)</span>                <span class="token comment">// [&quot;90&quot;]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h5 id="_7-3-后行断言的问题" tabindex="-1"><a class="header-anchor" href="#_7-3-后行断言的问题" aria-hidden="true">#</a> 7.3 后行断言的问题</h5><p>“后行断言”的实现，需要先匹配<code>/(?&lt;=y)x/</code>的x，然后再回到左边，匹配y的部分。这种“先右后左”的执行顺序，与所有其他正则操作相反，导致了一些不符合预期的行为。</p><p>暂略。</p><h4 id="_8-具名组匹配" tabindex="-1"><a class="header-anchor" href="#_8-具名组匹配" aria-hidden="true">#</a> 8. 具名组匹配</h4><h5 id="_8-1-组匹配" tabindex="-1"><a class="header-anchor" href="#_8-1-组匹配" aria-hidden="true">#</a> 8.1 组匹配</h5><p>正则表达式使用圆括号进行组匹配。每一组的匹配含义不容易看出来，而且只能用数字序号（比如matchObj[1]）引用，要是组的顺序变了，引用的时候就必须修改序号。</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">const</span> <span class="token constant">RE_DATE</span> <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">(\\d{4})-(\\d{2})-(\\d{2})</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">;</span>
<span class="token keyword">const</span> matchObj <span class="token operator">=</span> <span class="token constant">RE_DATE</span><span class="token punctuation">.</span><span class="token function">exec</span><span class="token punctuation">(</span><span class="token string">&#39;1999-12-31&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> year <span class="token operator">=</span> matchObj<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 1999</span>
<span class="token keyword">const</span> month <span class="token operator">=</span> matchObj<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 12</span>
<span class="token keyword">const</span> day <span class="token operator">=</span> matchObj<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 31</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h5 id="_8-2-具名组匹配" tabindex="-1"><a class="header-anchor" href="#_8-2-具名组匹配" aria-hidden="true">#</a> 8.2 具名组匹配</h5><p>为每一个组匹配指定一个名字，既便于阅读代码，又便于引用。如下“具名组匹配”在圆括号内部，模式的头部添加“问号 + 尖括号 + 组名”（?<code>&lt;year&gt;</code>），然后就可以在exec方法返回结果的groups属性上引用该组名。同时，数字序号（matchObj[ 1]）依然有效</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">const</span> <span class="token constant">RE_DATE</span> <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">(?&lt;year&gt;\\d{4})-(?&lt;month&gt;\\d{2})-(?&lt;day&gt;\\d{2})</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">;</span>
<span class="token keyword">const</span> matchObj <span class="token operator">=</span> <span class="token constant">RE_DATE</span><span class="token punctuation">.</span><span class="token function">exec</span><span class="token punctuation">(</span><span class="token string">&#39;1999-12-31&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> year <span class="token operator">=</span> matchObj<span class="token punctuation">.</span>groups<span class="token punctuation">.</span>year<span class="token punctuation">;</span> <span class="token comment">// &quot;1999&quot;</span>
<span class="token keyword">const</span> month <span class="token operator">=</span> matchObj<span class="token punctuation">.</span>groups<span class="token punctuation">.</span>month<span class="token punctuation">;</span> <span class="token comment">// &quot;12&quot;</span>
<span class="token keyword">const</span> day <span class="token operator">=</span> matchObj<span class="token punctuation">.</span>groups<span class="token punctuation">.</span>day<span class="token punctuation">;</span> <span class="token comment">// &quot;31&quot;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h5 id="_8-3-具名组匹配的解构赋值" tabindex="-1"><a class="header-anchor" href="#_8-3-具名组匹配的解构赋值" aria-hidden="true">#</a> 8.3 具名组匹配的解构赋值</h5><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">let</span> <span class="token punctuation">{</span><span class="token literal-property property">groups</span><span class="token operator">:</span> <span class="token punctuation">{</span>one<span class="token punctuation">,</span> two<span class="token punctuation">}</span><span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">^(?&lt;one&gt;.*):(?&lt;two&gt;.*)$</span><span class="token regex-delimiter">/</span><span class="token regex-flags">u</span></span><span class="token punctuation">.</span><span class="token function">exec</span><span class="token punctuation">(</span><span class="token string">&#39;foo:bar&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h5 id="_8-4-具名组匹配的引用" tabindex="-1"><a class="header-anchor" href="#_8-4-具名组匹配的引用" aria-hidden="true">#</a> 8.4 具名组匹配的引用</h5><p>果要在正则表达式内部引用某个“具名组匹配”，可以使用\\k&lt;组名&gt;的写法。</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">const</span> <span class="token constant">RE_TWICE</span> <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">^(?&lt;word&gt;[a-z]+)!\\k&lt;word&gt;$</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">;</span> <span class="token comment">//数字引用依然有效</span>
<span class="token constant">RE_TWICE</span><span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span><span class="token string">&#39;abc!abc&#39;</span><span class="token punctuation">)</span> <span class="token comment">// true</span>
<span class="token constant">RE_TWICE</span><span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span><span class="token string">&#39;abc!ab&#39;</span><span class="token punctuation">)</span> <span class="token comment">// false</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,58),o=[p];function c(l,i){return s(),n("div",null,o)}const d=a(t,[["render",c],["__file","2-2.正则扩展.html.vue"]]);export{d as default};
