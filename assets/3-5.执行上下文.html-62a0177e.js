import{_ as n,o as a,c as s,e}from"./app-2b89a278.js";const t="/front-doc/img/basic/js/3-5-1.jpg",p={},i=e(`<p>执行上下文（Execution Context）就是当前 JavaScript 代码被解析和执行时所在环境的抽象概念， JavaScript 中运行任何的代码都是在执行上下文中运行。</p><h4 id="_1-执行上下文的类型" tabindex="-1"><a class="header-anchor" href="#_1-执行上下文的类型" aria-hidden="true">#</a> 1. 执行上下文的类型</h4><ul><li>全局：默认的、最基础的执行上下文。不在任何函数中的代码都位于全局执行上下文中。它做了两件事：①创建一个全局对象，在浏览器中这个全局对象就是 window 对象。②将 this 指针指向这个全局对象。 <ul><li>一个程序中只能存在一个全局执行上下文。</li></ul></li><li>函数：每次调用函数时，都会为该函数创建一个新的执行上下文。每个函数都拥有自己的执行上下文，但是只有在函数被调用的时候才会被创建。一个程序中可以存在任意数量的函数执行上下文。每当一个新的执行上下文被创建，它都会按照特定的顺序执行一系列步骤。</li><li>Eval函数：运行在 eval 函数中的代码也获得了自己的执行上下文。</li></ul><h4 id="_2-执行上下文的生命周期" tabindex="-1"><a class="header-anchor" href="#_2-执行上下文的生命周期" aria-hidden="true">#</a> 2. 执行上下文的生命周期</h4><h5 id="_2-1-创建阶段-全局" tabindex="-1"><a class="header-anchor" href="#_2-1-创建阶段-全局" aria-hidden="true">#</a> 2.1 创建阶段- 全局</h5><p>在一段 JS 脚本执行之前，要先解析代码（所以说 JS 是解释执行的脚本语言），解析的时候会先创建一个全局执行上下文环境，先把代码中即将执行的变量、函数声明都拿出来。变量先暂时赋值为 undefined，函数则先声明好可使用。这一步做完了，然后再开始正式执行程序。</p><h5 id="_2-2-创建阶段-函数" tabindex="-1"><a class="header-anchor" href="#_2-2-创建阶段-函数" aria-hidden="true">#</a> 2.2 创建阶段- 函数</h5><p>一个函数在执行之前，也会创建一个函数执行上下文环境，跟全局上下文差不多，不过 函数执行上下文中会多出 this arguments 和函数的参数。当函数被调用，但未执行任何其内部代码之前，会做以下三件事：</p><ul><li>创建变量对象：首先初始化函数的参数 arguments，提升函数声明和变量声明。</li><li>创建作用域链（Scope Chain）：在执行期上下文的创建阶段，作用域链是在变量对象之后创建的。作用域链本身包含变量对象。作用域链用于解析变量。当被要求解析变量时JavaScript 始终从代码嵌套的最内层开始，如果最内层没有找到变量，就会跳转到上一层父作用域中查找，直到找到该变量。</li><li>确定 this 指向：包括多种情况（一共四种情况，见：./构造函数）。</li></ul><h5 id="_2-3-执行阶段" tabindex="-1"><a class="header-anchor" href="#_2-3-执行阶段" aria-hidden="true">#</a> 2.3 执行阶段</h5><p>执行变量赋值、代码执行。</p><h5 id="_2-4-回收阶段" tabindex="-1"><a class="header-anchor" href="#_2-4-回收阶段" aria-hidden="true">#</a> 2.4 回收阶段</h5><p>执行上下文出栈等待虚拟机回收执行上下文。</p><h4 id="_3-变量声明提升" tabindex="-1"><a class="header-anchor" href="#_3-变量声明提升" aria-hidden="true">#</a> 3. 变量声明提升</h4><p>JS中，变量可以先使用，后声明( 不过没有值 )。</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// undefined：表示已经声明了，只是没值</span>
<span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
<span class="token operator">===</span><span class="token operator">=</span>相当于以下代码<span class="token operator">===</span><span class="token operator">=</span>
<span class="token keyword">var</span> a<span class="token punctuation">;</span> <span class="token comment">//声明 默认值是undefined “准备工作”</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>
a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span> <span class="token comment">//赋值</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_4-函数声明提升" tabindex="-1"><a class="header-anchor" href="#_4-函数声明提升" aria-hidden="true">#</a> 4. 函数声明提升</h4><p>使用函数声明形式创建的函数会进行声明提升，他会在所有的代码执行之前就被创建。所以可以在函数声明前进行调用。使用函数表达式创建的函数，不会被声明提前，所以不能在声明前调用。</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>f1<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// function f1(){}</span>
<span class="token keyword">function</span> <span class="token function">f1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token comment">// 函数声明</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>f2<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// undefined</span>
<span class="token keyword">var</span> <span class="token function-variable function">f2</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">// 函数表达式</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>命名冲突: 当遇到函数和变量同名且都会被提升的情况，函数声明优先级比较高，因此变量声明会被函数声明所覆盖，但是可以重新赋值。</p><h4 id="_5-执行上下文栈" tabindex="-1"><a class="header-anchor" href="#_5-执行上下文栈" aria-hidden="true">#</a> 5. 执行上下文栈</h4><p>函数多了，就有多个函数执行上下文，每次调用函数创建一个新的执行上下文，那如何管理创建的那么多执行上下文呢？</p><p>JavaScript 引擎创建了执行上下文栈（Execution Context Stack）来管理执行上下文。可以把执行上下文栈认为是一个存储函数调用的栈结构，遵循先进后出的原则。</p><figure><img src="`+t+'" alt="3-5-1" tabindex="0" loading="lazy"><figcaption>3-5-1</figcaption></figure><p>执行规则如下：</p><ul><li>JavaScript 执行在单线程上，所有的代码都是排队执行。</li><li>一开始浏览器执行全局的代码时，首先创建全局的执行上下文，压入执行栈的顶部。</li><li>每当进入一个函数的执行就会创建函数的执行上下文，并且把它压入执行栈的顶部。当前函数执行完成后，当前函数的执行上下文出栈，并等待垃圾回收。</li><li>浏览器的 JS 执行引擎总是访问栈顶的执行上下文。</li><li>全局上下文只有唯一的一个，它在浏览器关闭时出栈。</li></ul>',26),c=[i];function o(l,r){return a(),s("div",null,c)}const d=n(p,[["render",o],["__file","3-5.执行上下文.html.vue"]]);export{d as default};
