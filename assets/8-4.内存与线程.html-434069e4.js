import{_ as a,o as i,c as e,e as h}from"./app-c07941ad.js";const r={},d=h('<h2 id="i-内存" tabindex="-1"><a class="header-anchor" href="#i-内存" aria-hidden="true">#</a> Ⅰ. 内存</h2><h4 id="_1-数据" tabindex="-1"><a class="header-anchor" href="#_1-数据" aria-hidden="true">#</a> 1. 数据</h4><p>存在于内存中可读，可操纵的东西，一切皆数据，函数也是数据。<br> 内存存在的意义，就是对数据进行操作。</p><h4 id="_2-内存" tabindex="-1"><a class="header-anchor" href="#_2-内存" aria-hidden="true">#</a> 2. 内存</h4><ul><li>内存条的空间：内存条通电后产生的存储空间(临时的)就是内存，内存是临时性的储存，是有声明周期的。</li><li>内存的声明周期：内存条==》通电==》产生内存空间==》储存数据==》断电==》内存空间和数据都消失</li><li>内存储存的数据类型 <ul><li>数据：直接储存数据【普通类型】</li><li>内存地址：储存其他内存块的地址【引用类型】。</li></ul></li><li>内存空间的分类 <ul><li>栈：全局变量和局部变量的值和对象的地址储存在这里。</li><li>堆：对象储存在这里。</li></ul></li></ul><h4 id="_3-变量值" tabindex="-1"><a class="header-anchor" href="#_3-变量值" aria-hidden="true">#</a> 3. 变量值</h4><p>值的标识符，该标识符是可变的，就称为变量。<br> 一个变量对应一小块内存，他的值保存在内存中，即内存中的<code>数据==变量的值</code></p><h4 id="_4-变量名" tabindex="-1"><a class="header-anchor" href="#_4-变量名" aria-hidden="true">#</a> 4. 变量名</h4><p>内存中储存的是变量的值，变量的名是不会储存的，变量的名可以理解为内存的地址标识。</p><p>变量名是给我们程序员操作内存来使用的。比如我们定义了一个全局的int a;那么编译器都为我们做了什么呢？它会为程序预留4个字节的空间（假设在32位平台），并把我们的变量名“a”保存进符号表，并用这个符号表的索引对应实际的空间。这是写编译器需要做的，我们需要建立符号表。变量名编译后，变成一个内存地址，这个内存地址一般是直接存在于代码段中</p><h4 id="_5-内存、数据、变量间的关系" tabindex="-1"><a class="header-anchor" href="#_5-内存、数据、变量间的关系" aria-hidden="true">#</a> 5. 内存、数据、变量间的关系</h4><p>内存是容器, 用来存储不同数据；</p><p>变量是内存的标识, 通过变量我们可以操作(读/写)内存中的数据；</p><h4 id="_6-垃圾回收gc" tabindex="-1"><a class="header-anchor" href="#_6-垃圾回收gc" aria-hidden="true">#</a> 6. 垃圾回收GC</h4><p>就像人生活的事件长了会产生垃圾一样，程序运行过程总也会产生垃圾，这些垃圾积攒过多以后，会导致程序运行的速度过慢，所以我们需要一个垃圾回收的机制，来处理程序运行过程中产生的垃圾。</p><p>当一个对象，没有任何的变量或属性对它进行引用，此时我们将永远无法操作该对象，此时这种对象就是一个垃圾。这种对象过多，会占用大量的内存空间，导致程序运行过慢，所以需要进行清理。</p><p>JS中拥有自动的垃圾回收机制，会自动将这些垃圾对象从内存中销毁，我们不需要也不能进行垃圾回收的操作。将对象变成垃圾，我们需要做的只是将不在使用的对象设置为null。</p><h4 id="_7-内存溢出与泄露" tabindex="-1"><a class="header-anchor" href="#_7-内存溢出与泄露" aria-hidden="true">#</a> 7. 内存溢出与泄露</h4><h5 id="_7-1-溢出" tabindex="-1"><a class="header-anchor" href="#_7-1-溢出" aria-hidden="true">#</a> 7.1 溢出</h5><p>一种程序运行出现的错误，当程序运行需要的内存超过了剩余的内存时, 就出抛出内存溢出的错误。</p><h5 id="_7-2-泄露" tabindex="-1"><a class="header-anchor" href="#_7-2-泄露" aria-hidden="true">#</a> 7.2 泄露</h5><p>占用的内存没有及时释放，泄露积累多了就容易导致内存溢出。</p><p>常见的内存泄露</p><ul><li>意外的全局变量</li><li>没有及时清理的计时器或回调函数</li><li>闭包</li></ul><h2 id="ii-进程与线程" tabindex="-1"><a class="header-anchor" href="#ii-进程与线程" aria-hidden="true">#</a> Ⅱ. 进程与线程</h2><h4 id="_1-进程" tabindex="-1"><a class="header-anchor" href="#_1-进程" aria-hidden="true">#</a> 1. 进程</h4><p>程序的一次执行, 它占有一片独有的内存空间</p><p>可以通过windows任务管理器查看进程</p><h4 id="_2-线程" tabindex="-1"><a class="header-anchor" href="#_2-线程" aria-hidden="true">#</a> 2. 线程</h4><ul><li>是进程内的一个独立执行单元</li><li>是程序执行的一个完整流程</li><li>是CPU的最小的调度单元</li></ul><h4 id="_3-进行与线程的关系" tabindex="-1"><a class="header-anchor" href="#_3-进行与线程的关系" aria-hidden="true">#</a> 3. 进行与线程的关系</h4><p>一个进程至少有一个线程(主)。</p><p>程序是在某个进程中的某个线程执行的。</p><h4 id="_4-js线程" tabindex="-1"><a class="header-anchor" href="#_4-js线程" aria-hidden="true">#</a> 4. JS线程</h4><ul><li>js是单线程执行的(回调函数也是在主线程)</li><li>H5提出了实现多线程的方案: Web Workers</li><li>只能是主线程更新界面</li></ul><h2 id="iii-浏览器内核" tabindex="-1"><a class="header-anchor" href="#iii-浏览器内核" aria-hidden="true">#</a> Ⅲ. 浏览器内核</h2><h4 id="_1-主线程" tabindex="-1"><a class="header-anchor" href="#_1-主线程" aria-hidden="true">#</a> 1. 主线程</h4><ul><li>js引擎模块 : 负责js程序的编译与运行</li><li>html,css文档解析模块 : 负责页面文本的解析</li><li>DOM/CSS模块 : 负责dom/css在内存中的相关处理</li><li>布局和渲染模块 : 负责页面的布局和效果的绘制(内存中的对象)</li></ul><h4 id="_2-分线程" tabindex="-1"><a class="header-anchor" href="#_2-分线程" aria-hidden="true">#</a> 2. 分线程</h4><ul><li>定时器模块 : 负责定时器的管理</li><li>DOM事件模块 : 负责事件的管理</li><li>网络请求模块 : 负责Ajax请求</li></ul>',40),l=[d];function n(s,c){return i(),e("div",null,l)}const _=a(r,[["render",n],["__file","8-4.内存与线程.html.vue"]]);export{_ as default};
