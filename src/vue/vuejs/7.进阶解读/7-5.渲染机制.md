---
title: "7-5. 渲染机制"
date: 2023-05-04
---

## Ⅰ. 渲染机制介绍
Vue 的渲染系统是基于虚拟 DOM构建的。

#### 1. 虚拟DOM
定义：虚拟 DOM (Virtual DOM，简称 VDOM) 是一种编程概念，意为将目标所需的 UI 通过数据结构“虚拟”地表示出来，保存在内存中，然后将真实的 DOM 与之保持同步。

如下示例：
```js
const vnode = {
  type: 'div',
  props: {
    id: 'hello'
  },
  children: [
    /* 更多 vnode */
  ]
}
```
- vnode：指的是一个纯 JavaScript 的对象 (一个“虚拟节点”)，它代表着一个 `<div>` 元素。它包含创建实际元素所需的所有信息。
    - 它还包含更多的子节点，这使它成为虚拟 DOM 树的根节点。
- 挂载：一个运行时渲染器将会遍历整个虚拟 DOM 树，并据此构建真实的 DOM 树。这个过程被称为挂载 (mount)。
- 更新：如果有两份虚拟 DOM 树，渲染器将会有比较地遍历它们，找出它们之间的区别，并应用这其中的变化到真实的 DOM 上。这个过程被称为更新 (patch)，又被称为“比对”(diffing) 或“协调”(reconciliation)。

总结：虚拟 DOM 带来的主要收益是它让开发者能够灵活、声明式地创建、检查和组合所需 UI 的结构，同时只需把具体的 DOM 操作留给渲染器去处理。

#### 2. 渲染管线
从高层面的视角看，Vue 组件挂载时会发生如下几件事：
- 编译：Vue 模板被编译为渲染函数：即用来返回虚拟 DOM 树的函数。
    - 这一步骤可以通过构建步骤提前完成，也可以通过使用运行时编译器即时完成。
- 挂载：运行时渲染器调用渲染函数，遍历返回的虚拟 DOM 树，并基于它创建实际的 DOM 节点。
    - 这一步会作为响应式副作用执行，因此它会追踪其中所用到的所有响应式依赖。
- 更新：当一个依赖发生变化后，副作用会重新运行，这时候会创建一个更新后的虚拟 DOM 树。
    - 运行时渲染器遍历这棵新树，将它与旧树进行比较，然后将必要的更新应用到真实 DOM 上去。

#### 3. 模板与渲染函数
Vue 模板会被预编译成虚拟 DOM 渲染函数。Vue 也提供了 API 使我们可以不使用模板编译，直接手写渲染函数。
##### 3.1 模板的使用
- 模板更贴近实际的 HTML。这使得我们能够更方便地重用一些已有的 HTML 代码片段，能够带来更好的可访问性体验、能更方便地使用 CSS 应用样式，并且更容易使设计师理解和修改。
- 由于其确定的语法，更容易对模板做静态分析。这使得 Vue 的模板编译器能够应用许多编译时优化来提升虚拟 DOM 的性能表现。
##### 3.2 渲染函数的使用
渲染函数一般只会在需要处理高度动态渲染逻辑的可重用组件中使用。

#### 4. 传统虚拟DOM的缺点
更新算法无法预知新的虚拟 DOM 树会是怎样，因此它总是需要遍历整棵树、比较每个 vnode 上 props 的区别来确保正确性。另外，即使一棵树的某个部分从未改变，还是会在每次重渲染时创建新的 vnode，带来了大量不必要的内存压力。

这种有点暴力的更新过程通过牺牲效率来换取声明式的写法和最终的正确性。


#### 5. 带编译时信息的虚拟DOM
在 Vue 中，框架同时控制着编译器和运行时，可以为紧密耦合的模板渲染器应用许多编译时优化。
编译器可以静态分析模板并在生成的代码中留下标记，使得运行时尽可能地走捷径。  
同时，仍旧保留了边界情况时用户想要使用底层渲染函数的能力。我们称这种混合解决方案为带编译时信息的虚拟 DOM。

##### 5.1 静态提升
在模板中常常有部分内容是不带任何动态绑定的，如下：
```html
<div>
  <div>foo</div> <!-- 需提升 -->
  <div>bar</div> <!-- 需提升 -->
  <div>{{ dynamic }}</div>
</div>
```
- foo 和 bar 这两个 div 是完全静态的，没有必要在重新渲染时再次创建和比对它们。
- Vue 编译器自动地会提升这部分 vnode 创建函数到这个模板的渲染函数之外，并在每次渲染时都使用这份相同的 vnode，渲染器知道新旧 vnode 在这部分是完全相同的，所以会完全跳过对它们的差异比对。
- 当有足够多连续的静态元素时，它们还会再被压缩为一个“静态 vnode”
- 这些静态节点会直接通过 innerHTML 来挂载。同时还会在初次挂载后缓存相应的 DOM 节点。如果这部分内容在应用中其他地方被重用，那么将会使用原生的 cloneNode() 方法来克隆新的 DOM 节点，这会非常高效。


## Ⅱ. 渲染函数
:::warning
暂略。
:::

## Ⅲ. JSX
:::warning
暂略。
:::