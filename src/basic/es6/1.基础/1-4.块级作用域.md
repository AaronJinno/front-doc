---
title: 1-4. 块级作用域
date: 2023-05-16
---
## Ⅰ. 块级作用域
#### 1. 为什么需要块级作用域
ES5没有块级作用域，只有函数和全局作用域，在一些场景中，产生了“闭包”现象。而这些场景，如果使用let（块级作用域）就不会产生闭包

##### 1.1 函数闭包：内层变量覆盖外层变量
```js
var tmp = "ok";
function f() {
  console.log(tmp);
  if (false) {
    var tmp = 'hello world'; //函数作用域内，外部tmp被覆盖，
  }
}
f(); // undefined：变量提升，在函数内部，内部的tmp覆盖了上层tmp
console.log(tmp); //ok;
```

##### 1.2 循环闭包：变量泄露
```js
var s = 'hello';

for (var i = 0; i < s.length; i++) {
  console.log(s[i]);
}
console.log(i); // 5 ，变量i只是用来控制循环的，循环结束成了全局变量
```

#### 2. ES6的块级作用域
ES6使用let增加了块级作用域，ES6 允许块级作用域的任意嵌套，每一层都是一个单独的作用域

注意，最外层是块级作用域的外层，所以，最外层无法读块级作用域的数据，反过来可以。
```js
{{{{
  {let insane = 'Hello World'}
  // 报错：第四层作用域无法读取第五层作用域的内部变量。
  console.log(insane); // 反过来是可以的，因为作用域链的关系
}}}};

====
{{{{
  let insane = 'Hello World';
  {let insane = 'Hello World'} //内层作用域可以定义外层作用域的同名变量。
}}}};
```

#### 3. let取代IIFE
let的出现，使匿名立即执行函数表达式（匿名IIFE）不再必要了。
```js
// IIFE 写法:模拟块级作用域
(function () {
  var tmp = ...;
  ...
}());
// 块级作用域写法
{
  let tmp = ...;
  ...
}
```
#### 4. 块级作用域与函数声明
##### 4.1 块级作用域能否声明函数
能，ES5规定只能在全局和函数作用域内声明函数，ES6规定块级也可以，浏览器一开始就默认了块级也可以声明函数。但是由于在块级作用域声明函数会对老代码才生较大的影响，很多浏览器会直接吧块级作用域里声明的函数报错，因此尽量不声明块级作用域的函数。
如果真的需要，应该写成函数表达式，而不是函数声明语句。

##### 4.2 声明块级函数
ES6 规定，块级作用域之中，函数声明语句的行为类似于let，在块级作用域之外不可引用。
```js
{
    let a = "hello"
    let f = function(){ //如果写成函数声明语句，可能会报错。
        return a;
    }
}
```
##### 4.3 大括号{}
ES6 的块级作用域必须有大括号，如果没有大括号，JavaScript 就认为不存在块级作用域。一律加大括号就行了(比如if语句)
```js
// 第一种写法，报错
if (true) let x = 1; //这不是块级作用域，let要出现在当前作用域的顶层，所以报错。
'use strict';
if (true)
  function f() {}
  
// 第二种写法，不报错
if (true) {
  let x = 1;
}
'use strict';
if (true) {
  function f() {}
}
```

#### 5. 总结
- 块级作用域的优点：块级作用域可以解决闭包问题（函数和循环闭包）。可以用来模块化编程，封装数据（外层代码无法访问内层的数据）
- 块级数据的定义：块内的数据必须使用const和let定义。如果使用var进行定义，数据的范围将直接跑到最外层，被所有程序访问。
- 嵌套：可以嵌套任意层，外层不可以访问内层数据，反过来可以。


## Ⅱ. 顶层对象的属性
JavaScript 语言存在一个顶层对象，它提供全局环境（即全局作用域），所有代码都是在这个环境中运行。在浏览器环境指的是window对象，在 Node 指的是global对象。

#### 1. ES5的顶层对象
ES5 之中，顶层对象的属性与全局变量是等价的。
```js
//顶层对象的属性赋值与全局变量的赋值，是同一件事
window.a = 1;
a // 1
a = 2;
window.a // 2
```
这是JS设计上的最大败笔，有以下几个问题。
- 没法在编译时就报出变量未声明的错误，只有运行时才能知道
- 程序员很容易不知不觉地就创建了全局变量
- 顶层对象的属性是到处可以读写的，这非常不利于模块化编程

#### 2. ES6的顶层对象
为了兼容性，ES6中使用var命令和function命令声明的全局变量，依旧是顶层对象的属性；另一方面规定，let命令、const命令、class命令声明的全局变量，不属于顶层对象的属性。

从 ES6 开始，全局变量将逐步与顶层对象的属性脱钩。
```js
var a = 1;
window.a // 1
let b = 1;
window.b // undefined
```


