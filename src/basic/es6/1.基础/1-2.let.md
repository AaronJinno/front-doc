---
title: 1-2. let
date: 2023-05-16
---
let命令类似于var，ES6新增，用于声明变量，只在let命令所在的代码块内有效。

let命令有很多自己的特性，这些特性保障了代码在运行时不出错，建议let代替var。

#### 1. 基本用法
let和var分别都可以用来声明变量，不过在代码块之外，只能调用var声明的变量。
```js
{
    let a=10;
    var b =1;
}
a //a is not defined.
```

##### 1.1 let声明格式
```js
let a;
let b,c,d;
let e = 100;
let f = 1,g = 2,h = 3;
```

##### 1.2 let 特性
- 变量不能重复声明
- 块级作用域
- 不存在变量提升
- 不影响作用域链：也就是块级作用域的子作用域可以找到该作用域的元素。

#### 2. let与var的for循环
for循环的计数器，很合适使用let命令，而不是var命令。
##### 2.1 在for循环中使用var
```js
var a = [];
for (var i = 0; i < 10; i++) {
  a[i] = function () {
    console.log(i);
  };
}
a[6](); // 输出的是10，无论i等于几，这里输出的都是10.
```

##### 2.2 在for循环中使用let
```js
var a = [];
for (let i = 0; i < 10; i++) {
  a[i] = function () {
    console.log(i);
  };
}
a[6](); // 6 
```
##### 2.3 var与let的对比
:::info 说明
首先：方法是必须先声明，再调用的，也就是说，调用方法时，`a[n]`已经声明好了。
也就是说，我们能调用`a[9]`，是因为`a[9]`已经声明好了，既然`a[9]`已经声明好了，就说明，我们再调用方法的时候，其实循环就已经走完了。该循环的意义就是批量声明方法，因为我们并没有直接在循环内进行调用。
:::
- var: var是全局定义变量的，var i 最终只有有唯一的一个i，已知循环已经走完了，所有这个时候，i就是他的最大值10；因此在调用函数时，无论传什么值，结果都是10.
- let: let是有块状作用域的，每个let i 都在自己的块内，彼此互相不覆盖。也就是定义的10个函数，彼此在各种的块状区域，每个区域都有一个独立的i，所以调用的时候，结果都是独立的。

独立的块，let i 是怎么循环累进的呢？这是因为 JavaScript 引擎内部会记住上一轮循环的值，初始化本轮的变量i时，就在上一轮循环的基础上进行计算。

另外，for循环还有一个特别之处，就是设置循环变量的那部分是一个父作用域，而循环体内部是一个单独的子作用域。

#### 3. 不存在变量提升
变量提升：即变量可以在声明之前使用，值为undefined。

var是存在变量提升的，而let就不存在，如果let在声明前调用，将报错。
```js
console.log(foo); // 输出undefined
var foo = 2;
console.log(bar); // 报错ReferenceError
let bar = 2;
```
#### 4. 暂时性死区
只要块级作用域内存在let命令，它所声明的变量就“绑定”（binding）这个区域，不再受外部的影响。在代码块内，使用let命令声明变量之前，该变量都是不可用的。在语法上，称为“暂时性死区”。


##### 4.1 示例
```js
var tmp = 123;
if (true) {
  tmp = 'abc'; //报错： ReferenceError
  let tmp;
}
```
上面代码中，存在全局变量tmp，但是块级作用域内let又声明了一个局部变量tmp，导致后者绑定这个块级作用域，所以在let声明变量前，对tmp赋值会报错。ES6 明确规定，如果区块中存在let和const命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。


##### 4.2 解析
也就是在let变量所在的区块中，该变量声明之前的区域都属于改变了的"死区",只要用到该变量就会报错，暂时性死区的本质就是，只要一进入当前作用域，所要使用的变量就已经存在了，但是不可获取，只有等到声明变量的那一行代码出现，才可以获取和使用该变量。如下所示：
```js
typeof x; //报错： ReferenceError
let x;
=======
typeof x; //x根本没有声明，直接使用，反而不会报错：返回undefined
=======
function bar(x = y, y = 2) {
  return [x, y]; 
}
bar(); // 报错,因为声明x=y时，y可能不存在。
=======
let x = x;  //报错： ReferenceError: x is not defined
```

#### 5. 不允许重复声明
let不允许在相同作用域内，重复声明同一个变量。
```js
function func() {
  let a = 10;// 报错
  var a = 1;
}
======
function func() {
  let a = 10;
  let a = 1;// 报错
}
=====
function func(arg) {
  let arg; //不能在函数内部重新声明参数。
}
func() // 报错
```



