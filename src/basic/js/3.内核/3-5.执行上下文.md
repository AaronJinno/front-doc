---
title: 3-5. 执行上下文
date: 2023-05-12
---
执行上下文（Execution Context）就是当前 JavaScript 代码被解析和执行时所在环境的抽象概念， JavaScript 中运行任何的代码都是在执行上下文中运行。

#### 1. 执行上下文的类型
- 全局：默认的、最基础的执行上下文。不在任何函数中的代码都位于全局执行上下文中。它做了两件事：①创建一个全局对象，在浏览器中这个全局对象就是 window 对象。②将 this 指针指向这个全局对象。
    - 一个程序中只能存在一个全局执行上下文。
- 函数：每次调用函数时，都会为该函数创建一个新的执行上下文。每个函数都拥有自己的执行上下文，但是只有在函数被调用的时候才会被创建。一个程序中可以存在任意数量的函数执行上下文。每当一个新的执行上下文被创建，它都会按照特定的顺序执行一系列步骤。
- Eval函数：运行在 eval 函数中的代码也获得了自己的执行上下文。

#### 2. 执行上下文的生命周期
##### 2.1 创建阶段- 全局
在一段 JS 脚本执行之前，要先解析代码（所以说 JS 是解释执行的脚本语言），解析的时候会先创建一个全局执行上下文环境，先把代码中即将执行的变量、函数声明都拿出来。变量先暂时赋值为 undefined，函数则先声明好可使用。这一步做完了，然后再开始正式执行程序。

##### 2.2 创建阶段- 函数
一个函数在执行之前，也会创建一个函数执行上下文环境，跟全局上下文差不多，不过 函数执行上下文中会多出 this arguments 和函数的参数。当函数被调用，但未执行任何其内部代码之前，会做以下三件事：
- 创建变量对象：首先初始化函数的参数 arguments，提升函数声明和变量声明。
- 创建作用域链（Scope Chain）：在执行期上下文的创建阶段，作用域链是在变量对象之后创建的。作用域链本身包含变量对象。作用域链用于解析变量。当被要求解析变量时JavaScript 始终从代码嵌套的最内层开始，如果最内层没有找到变量，就会跳转到上一层父作用域中查找，直到找到该变量。
- 确定 this 指向：包括多种情况（一共四种情况，见：./构造函数）。

##### 2.3 执行阶段
执行变量赋值、代码执行。

##### 2.4 回收阶段
执行上下文出栈等待虚拟机回收执行上下文。


#### 3. 变量声明提升
JS中，变量可以先使用，后声明( 不过没有值 )。
```js
console.log(a); // undefined：表示已经声明了，只是没值
var a = 10;
====相当于以下代码====
var a; //声明 默认值是undefined “准备工作”
console.log(a);
a = 10; //赋值
```

#### 4. 函数声明提升
使用函数声明形式创建的函数会进行声明提升，他会在所有的代码执行之前就被创建。所以可以在函数声明前进行调用。使用函数表达式创建的函数，不会被声明提前，所以不能在声明前调用。
```js
console.log(f1); // function f1(){}
function f1() {} // 函数声明
console.log(f2); // undefined
var f2 = function() {}; // 函数表达式
```
命名冲突: 当遇到函数和变量同名且都会被提升的情况，函数声明优先级比较高，因此变量声明会被函数声明所覆盖，但是可以重新赋值。

#### 5. 执行上下文栈
函数多了，就有多个函数执行上下文，每次调用函数创建一个新的执行上下文，那如何管理创建的那么多执行上下文呢？

JavaScript 引擎创建了执行上下文栈（Execution Context Stack）来管理执行上下文。可以把执行上下文栈认为是一个存储函数调用的栈结构，遵循先进后出的原则。

![3-5-1](/img/basic/js/3-5-1.jpg)

执行规则如下：
- JavaScript 执行在单线程上，所有的代码都是排队执行。
- 一开始浏览器执行全局的代码时，首先创建全局的执行上下文，压入执行栈的顶部。
- 每当进入一个函数的执行就会创建函数的执行上下文，并且把它压入执行栈的顶部。当前函数执行完成后，当前函数的执行上下文出栈，并等待垃圾回收。
- 浏览器的 JS 执行引擎总是访问栈顶的执行上下文。
- 全局上下文只有唯一的一个，它在浏览器关闭时出栈。




